// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "updates.proto" (package "updates", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message updates.Coordinates
 */
export interface Coordinates {
    /**
     * @generated from protobuf field: float x = 1;
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 2;
     */
    y: number;
    /**
     * @generated from protobuf field: float z = 3;
     */
    z: number;
}
/**
 * @generated from protobuf message updates.Orientation
 */
export interface Orientation {
    /**
     * @generated from protobuf field: float i = 1;
     */
    i: number;
    /**
     * @generated from protobuf field: float j = 2;
     */
    j: number;
    /**
     * @generated from protobuf field: float k = 3;
     */
    k: number;
    /**
     * @generated from protobuf field: float w = 4;
     */
    w: number;
}
/**
 * @generated from protobuf message updates.SpatialData
 */
export interface SpatialData {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: updates.Coordinates coordinates = 2;
     */
    coordinates?: Coordinates;
    /**
     * @generated from protobuf field: updates.Orientation orientation = 3;
     */
    orientation?: Orientation;
}
/**
 * @generated from protobuf message updates.SimulationUpdate
 */
export interface SimulationUpdate {
    /**
     * @generated from protobuf field: repeated updates.SpatialData spatial_updates = 1;
     */
    spatialUpdates: SpatialData[];
    /**
     * @generated from protobuf field: optional bool done = 2;
     */
    done?: boolean;
}
/**
 * @generated from protobuf message updates.InstructionUpdate
 */
export interface InstructionUpdate {
    /**
     * @generated from protobuf field: updates.Instruction instruction = 1;
     */
    instruction: Instruction;
}
/**
 * @generated from protobuf message updates.ChatMessage
 */
export interface ChatMessage {
    /**
     * @generated from protobuf field: string userId = 1;
     */
    userId: string;
    /**
     * @generated from protobuf field: string chat = 2;
     */
    chat: string;
}
/**
 * @generated from protobuf message updates.BatchedChatMessages
 */
export interface BatchedChatMessages {
    /**
     * @generated from protobuf field: repeated updates.ChatMessage chat = 1;
     */
    chat: ChatMessage[];
}
/**
 * @generated from protobuf message updates.GenericRequest
 */
export interface GenericRequest {
    /**
     * @generated from protobuf field: bool ok = 1;
     */
    ok: boolean;
}
/**
 * @generated from protobuf message updates.GenericResponse
 */
export interface GenericResponse {
    /**
     * @generated from protobuf field: bool ok = 1;
     */
    ok: boolean;
}
/**
 * @generated from protobuf enum updates.Instruction
 */
export enum Instruction {
    /**
     * @generated from protobuf enum value: Up = 0;
     */
    Up = 0,
    /**
     * @generated from protobuf enum value: Down = 1;
     */
    Down = 1,
    /**
     * @generated from protobuf enum value: Left = 2;
     */
    Left = 2,
    /**
     * @generated from protobuf enum value: Right = 3;
     */
    Right = 3,
    /**
     * @generated from protobuf enum value: Jump = 4;
     */
    Jump = 4,
    /**
     * @generated from protobuf enum value: Cw = 5;
     */
    Cw = 5,
    /**
     * @generated from protobuf enum value: Ccw = 6;
     */
    Ccw = 6
}
// @generated message type with reflection information, may provide speed optimized methods
class Coordinates$Type extends MessageType<Coordinates> {
    constructor() {
        super("updates.Coordinates", [
            { no: 1, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Coordinates>): Coordinates {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.x = 0;
        message.y = 0;
        message.z = 0;
        if (value !== undefined)
            reflectionMergePartial<Coordinates>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Coordinates): Coordinates {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float x */ 1:
                    message.x = reader.float();
                    break;
                case /* float y */ 2:
                    message.y = reader.float();
                    break;
                case /* float z */ 3:
                    message.z = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Coordinates, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* float y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Bit32).float(message.y);
        /* float z = 3; */
        if (message.z !== 0)
            writer.tag(3, WireType.Bit32).float(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message updates.Coordinates
 */
export const Coordinates = new Coordinates$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Orientation$Type extends MessageType<Orientation> {
    constructor() {
        super("updates.Orientation", [
            { no: 1, name: "i", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "j", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "k", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "w", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Orientation>): Orientation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.i = 0;
        message.j = 0;
        message.k = 0;
        message.w = 0;
        if (value !== undefined)
            reflectionMergePartial<Orientation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Orientation): Orientation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float i */ 1:
                    message.i = reader.float();
                    break;
                case /* float j */ 2:
                    message.j = reader.float();
                    break;
                case /* float k */ 3:
                    message.k = reader.float();
                    break;
                case /* float w */ 4:
                    message.w = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Orientation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float i = 1; */
        if (message.i !== 0)
            writer.tag(1, WireType.Bit32).float(message.i);
        /* float j = 2; */
        if (message.j !== 0)
            writer.tag(2, WireType.Bit32).float(message.j);
        /* float k = 3; */
        if (message.k !== 0)
            writer.tag(3, WireType.Bit32).float(message.k);
        /* float w = 4; */
        if (message.w !== 0)
            writer.tag(4, WireType.Bit32).float(message.w);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message updates.Orientation
 */
export const Orientation = new Orientation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpatialData$Type extends MessageType<SpatialData> {
    constructor() {
        super("updates.SpatialData", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "coordinates", kind: "message", T: () => Coordinates },
            { no: 3, name: "orientation", kind: "message", T: () => Orientation }
        ]);
    }
    create(value?: PartialMessage<SpatialData>): SpatialData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<SpatialData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpatialData): SpatialData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* updates.Coordinates coordinates */ 2:
                    message.coordinates = Coordinates.internalBinaryRead(reader, reader.uint32(), options, message.coordinates);
                    break;
                case /* updates.Orientation orientation */ 3:
                    message.orientation = Orientation.internalBinaryRead(reader, reader.uint32(), options, message.orientation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpatialData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* updates.Coordinates coordinates = 2; */
        if (message.coordinates)
            Coordinates.internalBinaryWrite(message.coordinates, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* updates.Orientation orientation = 3; */
        if (message.orientation)
            Orientation.internalBinaryWrite(message.orientation, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message updates.SpatialData
 */
export const SpatialData = new SpatialData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimulationUpdate$Type extends MessageType<SimulationUpdate> {
    constructor() {
        super("updates.SimulationUpdate", [
            { no: 1, name: "spatial_updates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SpatialData },
            { no: 2, name: "done", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SimulationUpdate>): SimulationUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spatialUpdates = [];
        if (value !== undefined)
            reflectionMergePartial<SimulationUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SimulationUpdate): SimulationUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated updates.SpatialData spatial_updates */ 1:
                    message.spatialUpdates.push(SpatialData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool done */ 2:
                    message.done = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SimulationUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated updates.SpatialData spatial_updates = 1; */
        for (let i = 0; i < message.spatialUpdates.length; i++)
            SpatialData.internalBinaryWrite(message.spatialUpdates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional bool done = 2; */
        if (message.done !== undefined)
            writer.tag(2, WireType.Varint).bool(message.done);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message updates.SimulationUpdate
 */
export const SimulationUpdate = new SimulationUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstructionUpdate$Type extends MessageType<InstructionUpdate> {
    constructor() {
        super("updates.InstructionUpdate", [
            { no: 1, name: "instruction", kind: "enum", T: () => ["updates.Instruction", Instruction] }
        ]);
    }
    create(value?: PartialMessage<InstructionUpdate>): InstructionUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.instruction = 0;
        if (value !== undefined)
            reflectionMergePartial<InstructionUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstructionUpdate): InstructionUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* updates.Instruction instruction */ 1:
                    message.instruction = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstructionUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* updates.Instruction instruction = 1; */
        if (message.instruction !== 0)
            writer.tag(1, WireType.Varint).int32(message.instruction);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message updates.InstructionUpdate
 */
export const InstructionUpdate = new InstructionUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChatMessage$Type extends MessageType<ChatMessage> {
    constructor() {
        super("updates.ChatMessage", [
            { no: 1, name: "userId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "chat", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChatMessage>): ChatMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.chat = "";
        if (value !== undefined)
            reflectionMergePartial<ChatMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChatMessage): ChatMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string userId */ 1:
                    message.userId = reader.string();
                    break;
                case /* string chat */ 2:
                    message.chat = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChatMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string userId = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string chat = 2; */
        if (message.chat !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.chat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message updates.ChatMessage
 */
export const ChatMessage = new ChatMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchedChatMessages$Type extends MessageType<BatchedChatMessages> {
    constructor() {
        super("updates.BatchedChatMessages", [
            { no: 1, name: "chat", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ChatMessage }
        ]);
    }
    create(value?: PartialMessage<BatchedChatMessages>): BatchedChatMessages {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.chat = [];
        if (value !== undefined)
            reflectionMergePartial<BatchedChatMessages>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchedChatMessages): BatchedChatMessages {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated updates.ChatMessage chat */ 1:
                    message.chat.push(ChatMessage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BatchedChatMessages, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated updates.ChatMessage chat = 1; */
        for (let i = 0; i < message.chat.length; i++)
            ChatMessage.internalBinaryWrite(message.chat[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message updates.BatchedChatMessages
 */
export const BatchedChatMessages = new BatchedChatMessages$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GenericRequest$Type extends MessageType<GenericRequest> {
    constructor() {
        super("updates.GenericRequest", [
            { no: 1, name: "ok", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GenericRequest>): GenericRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ok = false;
        if (value !== undefined)
            reflectionMergePartial<GenericRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenericRequest): GenericRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool ok */ 1:
                    message.ok = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GenericRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool ok = 1; */
        if (message.ok !== false)
            writer.tag(1, WireType.Varint).bool(message.ok);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message updates.GenericRequest
 */
export const GenericRequest = new GenericRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GenericResponse$Type extends MessageType<GenericResponse> {
    constructor() {
        super("updates.GenericResponse", [
            { no: 1, name: "ok", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GenericResponse>): GenericResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ok = false;
        if (value !== undefined)
            reflectionMergePartial<GenericResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenericResponse): GenericResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool ok */ 1:
                    message.ok = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GenericResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool ok = 1; */
        if (message.ok !== false)
            writer.tag(1, WireType.Varint).bool(message.ok);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message updates.GenericResponse
 */
export const GenericResponse = new GenericResponse$Type();
/**
 * @generated ServiceType for protobuf service updates.SimulationService
 */
export const SimulationService = new ServiceType("updates.SimulationService", [
    { name: "SubscribeToSimulation", serverStreaming: true, options: {}, I: GenericRequest, O: SimulationUpdate },
    { name: "SendInstruction", options: {}, I: InstructionUpdate, O: GenericResponse }
]);
/**
 * @generated ServiceType for protobuf service updates.ChatService
 */
export const ChatService = new ServiceType("updates.ChatService", [
    { name: "SubscribeToChat", serverStreaming: true, options: {}, I: GenericRequest, O: BatchedChatMessages },
    { name: "SendChat", options: {}, I: ChatMessage, O: GenericResponse }
]);
